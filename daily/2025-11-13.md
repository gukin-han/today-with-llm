# 2025-11-13

## 환경별 DB 인덱스 불일치 점검 방법

### 인덱스 전수 조사 쿼리

* dev / staging / prod에서 모두 동일한 쿼리로 인덱스 리스트를 뽑는다.
* MySQL 기준 예시:

```sql
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    INDEX_NAME,
    NON_UNIQUE,
    SEQ_IN_INDEX,
    COLUMN_NAME,
    COLLATION,
    INDEX_TYPE,
    SUB_PART
FROM information_schema.STATISTICS
WHERE TABLE_SCHEMA = 'your_db_name'
ORDER BY TABLE_NAME, INDEX_NAME, SEQ_IN_INDEX;
```

* 각 환경에서 CSV로 export하여 `indexes_dev.csv`, `indexes_stg.csv`, `indexes_prd.csv` 형태로 저장해 비교한다.

### 차이 비교 & 문서화

* 기준(Source of Truth)을 보통 **prod 스키마**로 잡는다.
* 비교 포인트:

  * prod에는 있는데 dev/stg에는 없는 인덱스
  * dev/stg에는 있는데 prod에는 없는 인덱스 (실험용/불필요 가능성)
  * 같은 이름인데 컬럼 순서, 유니크 여부가 다른 인덱스
* 문서화 예시:

  * `인덱스명 / 테이블 / prod 정의 / dev 정의 / stg 정의 / 액션(추가·삭제·재생성) / 비고` 형태의 표로 관리.

### 인덱스를 다시 맞추는 전략

* 누락 인덱스: prod 정의를 기준으로 dev/stg에 `ADD INDEX` 적용.
* 불필요 인덱스: 사용 여부·쿼리 플랜 확인 후 `DROP INDEX` 고려.
* 정의 차이: `DROP INDEX + ADD INDEX`로 prod와 동일하게 재정의.
* 모든 변경은 **수동 실행이 아니라 마이그레이션 스크립트(예: SQL 파일, 마이그레이션 도구)**로 관리한다.

---

## Docker 학습 전략과 `docker-lab` 구조

### docker-lab 레포 구조

* 주제별 실험 단위로 관리하는 랩 레포를 만든다.

```text
docker-lab/
├── README.md
└── topics/
    ├── 001-container-basics/
    │   ├── Dockerfile
    │   ├── notes-raw.md
    │   └── notes.md
    ├── 002-layer-and-build-cache/
    ├── 020-network-basics/
    ├── 030-volume-basics/
    ├── 040-compose-basics/
    ├── 050-prod-image-optimization/
    └── 060-cgroups-and-limits/
```

### notes-raw vs notes

* `notes-raw.md`: 실험 중 바로 적는 날것의 기록(명령, 로그, 느낌, 에러 등).
* `notes.md`: raw를 기반으로 정리된 최종 문서(목표, 실험 과정, 관찰, 개념 정리, 실무 의미).
* 패턴:

  * **본인은 실험 + raw 기록**
  * **LLM에게 정리(notes.md) 위임** → 재사용 가능한 지식 문서로 축적.

---

## 컨테이너의 본질: 컨테이너 = 프로세스

### PID namespace와 PID 1

* 컨테이너는 **독립된 PID namespace**를 가진다.

  * 컨테이너 내부: PID 1, 2, 3…
  * 호스트: 15324, 15325… 전혀 다른 번호.
* 컨테이너 내부의 **PID 1**은 특별한 역할:

  * 종료 시그널(SIGTERM 등)을 가장 먼저 받는다.
  * 자식 프로세스의 zombie 처리 책임을 가진다.
  * PID 1이 종료되면 컨테이너도 종료된다.

### 여러 프로세스가 보이는 이유

* ENTRYPOINT/CMD로 실행된 프로그램이 내부적으로 fork할 수 있다.

  * 예: nginx master + worker 프로세스들.
* ENTRYPOINT가 쉘 스크립트를 돌리는 경우:

  * PID 1 = `/bin/sh` 또는 `bash`,
  * 실제 앱 프로세스는 자식 프로세스가 된다.

---

## Dockerfile 문법과 쉘의 관계

### Dockerfile = Docker DSL + 쉘 명령

* Docker 고유 명령:

  * `FROM`, `RUN`, `COPY`, `ADD`, `CMD`, `ENTRYPOINT`, `ENV`, `WORKDIR` 등은 **Dockerfile DSL**.
* 쉘은 특정 구간에서만 동작:

  * `RUN`: 거의 항상 `/bin/sh -c "..."` 형태로 실행.
  * `CMD`, `ENTRYPOINT`의 shell form (`CMD java -jar app.jar`)일 때도 쉘을 거친다.

### exec form vs shell form

* exec form:

  ```dockerfile
  ENTRYPOINT ["java", "-jar", "app.jar"]
  ```

  * 쉘을 거치지 않고 바로 실행.
  * PID 1 = java 프로세스 → signal 처리, graceful shutdown 측면에서 권장.
* shell form:

  ```dockerfile
  ENTRYPOINT java -jar app.jar
  ```

  * 실제로는 `/bin/sh -c "java -jar app.jar"` 실행.
  * PID 1이 쉘이 되어 signal 전달 문제, zombie 처리 이슈가 생길 수 있다.

---

## Docker 네트워크와 포트 포워딩의 내부 동작

### 네트워크 네임스페이스와 veth pair

* 컨테이너 생성 시:

  * **network namespace**가 생성되어 컨테이너만의 `eth0`, 라우팅 테이블, IP가 생긴다.
  * 가상 이더넷 인터페이스 쌍(veth pair)이 생성된다.

    * 컨테이너 내부: `eth0`
    * 호스트: `vethXXXX`
* 호스트의 `docker0` 브리지(가상 스위치)에 `vethXXXX`가 연결되고, 이 브리지를 통해 컨테이너들끼리 통신한다.

### 포트 포워딩 = iptables NAT

* 예: `docker run -p 8080:80 app`

  * Docker가 내부적으로 iptables NAT 규칙을 추가한다.
  * DNAT: 호스트 `:8080` → 컨테이너 `172.17.0.X:80`
  * SNAT/MASQUERADE: 컨테이너 outbound 트래픽이 호스트 IP에서 나가는 것처럼 보이게 처리.
* 결론:

  * **컨테이너가 직접 포트를 여는 것이 아니라, 리눅스 커널이 iptables NAT를 통해 포워딩을 수행한다.**

---

## Docker 이미지 레이어와 dive

### 레이어 구조

* Docker 이미지는 레이어 스택으로 구성된다.

  * `FROM`, `RUN`, `COPY` 등 명령 하나가 레이어 하나를 만든다.
* 레이어는 불변이며, 위에 새로운 레이어가 쌓이는 형태로 변화가 기록된다.
* 이 구조 덕분에:

  * 빌드 캐시 활용 가능.
  * base 레이어를 여러 이미지에서 공유 가능.
  * 작은 변경만 새 레이어로 추가할 수 있다.

### dive의 역할

* `dive <이미지>`로 각 레이어에서:

  * 추가/수정/삭제된 파일 목록,
  * 레이어 크기,
  * 최적화 점수 등을 분석할 수 있다.
* 활용 포인트:

  * 불필요하게 비대해진 레이어 찾기.
  * 잘못된 `COPY`나 `RUN` 순서로 인한 캐시 깨짐 확인.
  * multi-stage build 전/후를 비교해 최적화 효과 검증.

---

## Python 실행 환경, Jupyter, Anaconda, uv

### VSCode에서 Python + Jupyter 구조

* VSCode에서:

  * Python 확장을 설치 → Python 인터프리터 선택.
  * Jupyter 확장을 설치 → 노트북 파일(`.ipynb`)에서 **커널(kernel)** 선택.
* 커널 = “어떤 Python 환경에서 코드를 실행할지”를 나타내는 실행 엔진.

  * 로컬 가상환경(venv, conda env 등),
  * 시스템 Python,
  * 특정 도커/원격 환경 등이 될 수 있다.

### “앱이 자체 파이썬 실행환경을 가진 경우”

* 특정 앱(예: 일부 데이터툴, IDE)은 자체 내장 Python을 가지고 올 수 있다.
* 이 경우:

  * 호스트에 Python을 따로 설치하지 않아도 **그 앱 안에서만** Python 코드 실행이 가능하다.
  * 다른 앱에서 재사용하려면 별도의 시스템/가상환경 Python이 필요하다.

### 가상환경과 버전

* 가상환경(venv/conda env)은:

  * 특정 Python 인터프리터 버전(예: 3.10)을 기반으로
  * 독립적인 site-packages 디렉토리를 갖는 구조.
* 호스트 Python을 지우더라도:

  * 가상환경이 호스트 인터프리터를 직접 가리키고 있었다면 깨질 수 있다.
  * 별도 바이너리로 포함된 형태라면 독립적으로 살아남을 수 있다(도구/설정에 따라 다름).

### Anaconda vs uv

* **Anaconda**

  * 데이터 과학/머신러닝 패키지를 통합 제공하는 배포판.
  * `conda` 명령으로 파이썬 버전 + 패키지 + 가상환경을 통합 관리.
* **uv**

  * Rust로 구현된 차세대 Python 패키지/환경 관리 도구.
  * pip, venv, pipx, poetry 역할을 통합하려는 지향.
  * 빠른 설치 속도, 캐시 효율, 의존성 관리 개선을 목표로 한다.

---

## 파일 시스템: 하드링크와 inode, 실제 파일 삭제 시점

### inode와 링크

* inode:

  * 파일의 메타데이터(크기, 위치, 권한 등)를 담는 구조체.
  * 실제 데이터 블록의 위치를 참조한다.
* 디렉터리 엔트리:

  * “파일명 → inode 번호”의 매핑.
  * 하나의 inode를 여러 디렉터리 엔트리가 가리킬 수 있다 → **하드링크**.

### 하드링크와 삭제

* “원본 파일”이라는 개념은 없고, **모든 하드링크는 동등**하다.
* `rm somefile`은:

  * 디렉터리에서 “파일명 → inode” 엔트리 하나를 제거할 뿐.
* 실제 데이터 삭제 조건:

  * 해당 inode를 참조하는 링크 카운트가 0이 되었고,
  * 그 inode를 열고 있는 프로세스도 더 이상 없을 때.
* 따라서:

  * “원본”을 삭제해도 다른 하드링크가 남아 있으면 파일은 유지된다.

---

## AWS S3에서의 Bucket과 ACL 용어

### Bucket

* S3에서 객체(object)를 저장하는 **최상위 컨테이너**.
* 전 세계에서 유일한 이름을 가져야 하고, 일종의 “논리적인 스토리지 단위” 역할을 한다.
* 예:

  * `app-prod-bucket`, `logs-archive-bucket` 등(실제 이름은 서비스별로 구성).

### ACL (Access Control List)

* 버킷/객체 단위의 **권한 제어 방식 중 하나**.
* “누가(read/write) 무엇을 할 수 있는지”를 객체/버킷 수준에서 정의하는 규칙 집합.
* 현재는 버킷 정책, IAM 정책 기반 제어가 선호되며, ACL은 필요한 경우에만 제한적으로 활용되는 편이다.

---

## CI/CD와 테스트 자동화의 위치

### CI (Continuous Integration)

* 주 기능:

  * 코드 변경 시 자동 빌드, 자동 테스트 실행.
  * 정적 분석, 코드 스타일 검사 등.
* 테스트 자동화:

  * 일반적으로 **CI 파이프라인에 포함**된다.
  * PR/브랜치에 변경이 들어올 때마다 테스트가 자동으로 돈다.

### CD (Continuous Delivery / Deployment)

* Delivery:

  * 배포 가능한 아티팩트를 자동으로 만들고, 실제 배포는 사람이 트리거.
* Deployment:

  * 특정 조건을 만족하면 자동으로 서비스 환경에 배포까지 진행.
* CI 결과물(이미지, 빌드 아티팩트)을 인프라 환경에 올리기 위한 단계.

---

## DevOps, 플랫폼팀, SRE의 지향점

### 공통점

* 개발과 운영 사이의 간극을 줄이고, 시스템 안정성과 배포 속도를 높이려는 방향성은 비슷하다.
* 자동화, 모니터링, 표준화된 플랫폼을 구축하는 데 관심이 있다.

### 차이 관점

* **DevOps**:

  * 문화·프로세스·조직 철학에 가까운 개념.
  * 개발과 운영이 협업하는 방식을 통칭.
* **플랫폼팀**:

  * 개발자들이 서비스 개발에 집중하도록, 공통 인프라/플랫폼(배포, 관측, 인증, 메시징 등)을 제공하는 팀.
* **SRE(Site Reliability Engineering)**:

  * 신뢰성/가용성을 엔지니어링 관점에서 다루는 역할.
  * 에러 예산, SLO/SLI, 장애 대응, 운영 자동화, 성능·신뢰성 튜닝에 집중.

---

## MySQL 컬럼 변경 쿼리 해석

### ALTER TABLE … CHANGE COLUMN …

```sql
ALTER TABLE TM_LEAVE_CRT 
CHANGE COLUMN IS_CLOSED IS_CLOSED 
    BOOLEAN 
    NULL 
    DEFAULT 0 
    COMMENT '마감여부';
```

* `ALTER TABLE TM_LEAVE_CRT`

  * 해당 테이블의 스키마를 수정.
* `CHANGE COLUMN IS_CLOSED IS_CLOSED`

  * 기존 컬럼 이름을 유지하면서 정의를 변경(MySQL 문법상 기존/새 이름을 모두 적어야 함).
* `BOOLEAN NULL DEFAULT 0`

  * 타입을 BOOLEAN(TINYINT(1)과 유사)로 지정.
  * NULL 허용.
  * 기본값 0.
* `COMMENT '마감여부'`

  * 컬럼 설명 메타데이터 추가.

→ 실제 의미: **기존 IS_CLOSED 컬럼을 “BOOLEAN NULL DEFAULT 0, 마감여부”로 재정의하는 쿼리**.
